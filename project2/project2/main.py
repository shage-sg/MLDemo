# -*- coding: utf-8 -*-import numpy as npimport torch as thimport pandas as pdimport seaborn as snsimport matplotlib as mplfrom cycler import cyclerimport matplotlib.pyplot as pltnp.random.seed(1)th.manual_seed(1)sns.set_style("darkgrid")mpl.rcParams['axes.prop_cycle'] = cycler(color=['#1f77b4', '#ff7f0e', '#2ca02c',                                                '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f',                                                '#bcbd22', '#17becf', '#00F5FF'])# %% 数据集data = pd.read_csv('winequality-red.csv', sep=';')data.info()data.describe()# %% LDA降维后可视化from sklearn.discriminant_analysis import LinearDiscriminantAnalysislda = LinearDiscriminantAnalysis(n_components=2)feature2D = lda.fit(data.loc[:, :'alcohol'], data.loc[:, 'quality']).transform(data.loc[:, :'alcohol'])feature2D = pd.DataFrame(feature2D, columns=['x1', 'x2'])# 添加标签列feature2D['quality'] = data['quality']# 关系图sns.relplot(data=feature2D, x='x1', y='x2', hue='quality', palette='coolwarm')# %% 数据集。  划分数据，创建 PyTorch 数据集类# TODO: 实现数据集类的有关方法from dataset import WineQualityDatasetpopulation = data.shape[0]# 打乱序号 不修改原数据序号idx = np.random.permutation(population)# 划分训练集、验证集、测试集，各有 900、300、399 个样本trainset = WineQualityDataset(data.loc[idx[:900]], tag='train')valset = WineQualityDataset(data.loc[idx[900:1200]], tag='validation',                            feature_mean=trainset.mean, feature_std=trainset.std)testset = WineQualityDataset(data.loc[idx[1200:]], tag='test',                             feature_mean=trainset.mean, feature_std=trainset.std)# %% 模型from torch import nnfeature_nums = 11model = nn.Linear(feature_nums, 1)# %% 训练from train import trainer# 训练器配置参数config = {'epoches': 5, 'batchsize': 16, 'lr': 0.02, 'lambd': 0.3, 'norm': 'L1'}trainloss, valloss, _ = trainer(trainset, valset, model, config)# %% 训练结果可视化plt.figure()plt.plot(trainloss, 'b-')plt.xlabel('iteration')plt.ylabel('loss')plt.title('training loss')plt.figure()plt.plot(valloss, 'r-')plt.xlabel('iteration')plt.ylabel('MAE')plt.title('validation loss')# %% 改变 lambda 观察权重衰减过程lambds = np.linspace(0, 2, 40)weights = pd.DataFrame(data=None, index=lambds,                       columns=['fixed acidity', 'volatile acidity', 'citric acid',                                'residual sugar', 'chlorides', 'free sulfur dioxide',                                'total sulfur dioxide', 'density', 'pH', 'sulphates', 'alcohol'])for lambd in lambds:    model = nn.Linear(feature_nums, 1)    config = {'epoches': 5, 'batchsize': 16, 'lr': 0.02, 'lambd': lambd, 'norm': 'L2'}    _, valloss, _ = trainer(trainset, valset, model, config)    weights.loc[lambd] = model.weight.detach().numpy()    print(f'lambda: {lambd:.3f}, minimum validation loss: {min(valloss):.3f}')plt.figure()plt.plot(weights)plt.xlabel('lambda')plt.ylabel('weight value')plt.legend(weights.columns, bbox_to_anchor=(1.04, 0.5), loc="center left")# %% 利用验证集寻找最佳学习率和批次大小lrs = [0.01, 0.02, 0.03, 0.04, 0.05]batchsizes = [8, 16, 32, 64, 128]for _, lr in enumerate(lrs):    for _, batchsize in enumerate(batchsizes):        model = nn.Linear(feature_nums, 1)        config = {'epoches': 6, 'batchsize': batchsize, 'lr': lr, 'lambd': 0, 'norm': 'L1'}        _, valloss, _ = trainer(trainset, valset, model, config)        print(f'lr: {lr:.2f}, batchsize: {batchsize:3d}, minimum validation loss: {min(valloss):.3f}')# %% 以最佳超参数训练模型，将验证误差最小的模型作为最终模型model = nn.Linear(feature_nums, 1)config = {'epoches': 6, 'batchsize': 8, 'lr': 0.03, 'norm': 'L1', 'lambd': 0}_, valloss, snapshots = trainer(trainset, valset, model, config, save_snapshot=True)best_parameters = snapshots[np.argmin(valloss)]model.load_state_dict(best_parameters)# 在测试集上测试# TODO: 实现 evaluate 方法from train import evaluatetest_feature, test_label = testset[:]with th.no_grad():    test_pred = model(test_feature)test_error = evaluate(test_pred, test_label).item()print(f'test error: {test_error:.3f}')# 可视化测试结果test_feature2D = lda.fit(test_feature, test_label.flatten()).transform(test_feature)test_feature2D = pd.DataFrame(test_feature2D, columns=['x1', 'x2'])test_feature2D['quality'] = test_labeltest_feature2D['predict quality'] = test_pred.detach().numpy()sns.relplot(data=test_feature2D, x='x1', y='x2', hue='quality', palette='coolwarm')sns.relplot(data=test_feature2D, x='x1', y='x2', hue='predict quality', palette='coolwarm')plt.show()