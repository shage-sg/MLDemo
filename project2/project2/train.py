# -*- coding: utf-8 -*-import torchimport torch as thimport copyfrom torch import optimfrom torch.utils.data import DataLoaderfrom criterion import lossFuncdef trainer(trainset, valset, model, config, save_snapshot=False):    trainloss = []    valloss = []    snapshots = []  # 保存模型快照    train_loader = DataLoader(trainset, batch_size=config['batchsize'], shuffle=True)    val_feature, val_label = valset[:]    optimizer = optim.SGD(model.parameters(), lr=config['lr'])    for epoch in range(config['epoches']):        for feature, label in train_loader:            # forward step            prediction = model(feature)            loss = lossFunc(prediction, label, model, config['lambd'], norm=config['norm'])            trainloss.append(loss.item())            valloss.append(lossFunc(model(val_feature), val_label, model, config['lambd'], norm=config['norm']).item())            # backward step            optimizer.zero_grad()            loss.backward()            # update parameters            optimizer.step()            # save snapshot            if save_snapshot:                snapshots.append(copy.deepcopy(model.state_dict()))    return trainloss, valloss, snapshotsdef evaluate(prediction, label):    # TODO: 实现 MAE 的计算    """    :param prediction: 预测值    :param label: 真实值    :return: MAE值    根据MAE计算公式，由于prediction和label的类型均为tensor张量，    使用torch的mean函数和abs函数实现代码    """    return torch.mean(torch.abs(prediction - label))