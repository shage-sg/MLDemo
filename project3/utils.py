# -*- coding: utf-8 -*-import torch as thfrom sklearn import metricsimport sysdef confusion_matrix(pred, label, thr):    pred_label = (pred > thr).type(th.float32)    # TODO: 实现混淆矩阵中 TP, FP, TN, FN 的计算    pass    # return TP, FP, TN, FNdef classification_metric(pred, label, thr):    assert pred.ndim == 1 and label.ndim == 1, '输入必须为一维向量'    TP, FP, TN, FN = confusion_matrix(pred, label, thr)    sample_size = pred.shape[0]    # TODO: 实现 accuracy, precision, recall, F1 score 的计算    # 注意：为了避免除零，在分母加上 sys.float_info.epsilon    pass    # return accuracy, precision, recall, F1            def roc_metric(pred, label):    assert pred.ndim == 1 and label.ndim == 1, '输入必须为一维向量'    # 从大到小排列预测值，label也要相应调整    idx = th.argsort(pred, descending=True)    pred = pred[idx]    label = label[idx]    # TPR = TP / (TP + FN), FPR = FP / (TN + FP)    thresholds = pred.tolist()    thresholds.append(0)    tpr = []    fpr = []    for thr in thresholds:        TP, FP, TN, FN = confusion_matrix(pred, label, thr)        tpr.append(TP / (TP + FN + sys.float_info.epsilon))        fpr.append(FP / (TN + FP + sys.float_info.epsilon))            # ROC 曲线下面积    auc = metrics.auc(fpr, tpr)    return auc, tpr, fpr, thresholds        