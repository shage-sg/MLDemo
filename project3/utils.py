# -*- coding: utf-8 -*-import torch as thfrom sklearn import metricsimport sysdef confusion_matrix(pred, label, thr):    pred_label = (pred > thr).type(th.int8)    label = label.type(th.int8)    # TODO: 实现混淆矩阵中 TP, FP, TN, FN 的计算    # TP:真阳性，预测为真，实际为真    result = pred_label ^ label  # 预测值和真实值 异或计算    result_count = th.bincount(result)  # 0、1标签值 数量统计    TP = th.count_nonzero(pred_label & label)    FP = th.count_nonzero(pred_label & ~label)    TN = result_count[0] - TP    FN = result_count[1] - FP    return TP, FP, TN, FNdef classification_metric(pred, label, thr):    assert pred.ndim == 1 and label.ndim == 1, '输入必须为一维向量'    TP, FP, TN, FN = confusion_matrix(pred, label, thr)    sample_size = pred.shape[0]    # TODO: 实现 accuracy, precision, recall, F1 score 的计算    # 注意：为了避免除零，在分母加上 sys.float_info.epsilon    accuracy = (TP + TN) / (TP + FP + TN + FN + sys.float_info.epsilon)    precision = TP / (TP + FP + sys.float_info.epsilon)    recall = TP / (TP + FN + sys.float_info.epsilon)    F1 = 2 * precision * recall / (precision + recall + sys.float_info.epsilon)    return accuracy, precision, recall, F1def roc_metric(pred, label):    assert pred.ndim == 1 and label.ndim == 1, '输入必须为一维向量'    # 从大到小排列预测值，label也要相应调整    idx = th.argsort(pred, descending=True)    pred = pred[idx]    label = label[idx]    # TPR = TP / (TP + FN), FPR = FP / (TN + FP)    thresholds = pred.tolist()    thresholds.append(0)    tpr = []    fpr = []    for thr in thresholds:        TP, FP, TN, FN = confusion_matrix(pred, label, thr)        tpr.append(TP / (TP + FN + sys.float_info.epsilon))        fpr.append(FP / (TN + FP + sys.float_info.epsilon))    # ROC 曲线下面积    auc = metrics.auc(fpr, tpr)    return auc, tpr, fpr, thresholds