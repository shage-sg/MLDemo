# -*- coding: utf-8 -*-import numpy as npimport pandas as pdimport picklenp.random.seed(1)#%% 词典with open('wdict.pkl', 'rb') as fh:    wdict = pickle.load(fh)print(f'词典大小: {len(wdict)}')print(f'前20个词: {wdict[:20]}')#%% 停用词with open('stopwords.pkl', 'rb') as fh:    stopwords = pickle.load(fh)print(f'停用词词典大小: {len(stopwords)}，类型: {type(stopwords)}')print(f'列举20个停用词: {list(stopwords)[:20]}')#%% 数据集.  需要先解压 trec06c.tgzwith open('trec06c/full/index', 'r') as fh:    lines = fh.readlines()label = []file = []for line in lines:    rs = line.split()    label.append(1) if rs[0] == 'spam' else label.append(0)    file.append(rs[1].strip('../'))df = pd.DataFrame(list(zip(file, label)), columns=['fpath', 'label'])idx = np.random.permutation(len(label))trainset = df.loc[idx[:54620], :].reset_index(drop=True)testset = df.loc[idx[54620:], :].reset_index(drop=True)trainset.head()trainset.info()#%% 模型# TODO: 完善朴素贝叶斯模型中相关功能from model import NaiveBayesmodel = NaiveBayes(trainset, wdict, stopwords, './trec06c')model.build()  # 需要一段时间，注意终端的输出#%% 测试from utils import classification_metrictestset_bow = model.generate_bow(testset)testset_label = testset.loc[:,'label'].to_numpy()testset_pred = np.zeros(testset.shape[0], dtype=np.int32)for i, row in enumerate(testset_bow):    # 为了防止下溢，把连乘改为对数连加    # 当邮件中没有任何词语在词典中时，比较的是 np.log(model.prob_spam) 和 np.log(model.prob_ham)，结果判定为’垃圾邮件‘    # 把反常邮件归类为垃圾邮件有一定道理    S = np.log(model.cond_spam[row==1]).sum() + np.log(model.prob_spam)    H = np.log(model.cond_ham[row==1]).sum() + np.log(model.prob_ham)    if S > H:        testset_pred[i] = 1accuracy, precision, recall, F1 = classification_metric(testset_pred, testset_label)print(f'accuracy: {accuracy:.3f}, precision: {precision:.3f}, recall: {recall:.3f}, F1 score: {F1:.3f}')